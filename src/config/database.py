"""
Postgres Database Backend for Configuration and State Management.

Provides a persistent database layer for storing configuration settings,
bot state, positions, orders, and trading history using PostgreSQL.
"""

import json
import logging
import os
from contextlib import contextmanager
from datetime import datetime
from typing import Any, Dict, Generator, List, Optional

from psycopg import sql
from psycopg.conninfo import make_conninfo
from psycopg.types.json import Jsonb
from psycopg_pool import ConnectionPool

logger = logging.getLogger(__name__)

DEFAULT_DB_URL = (
    os.getenv("DATABASE_URL")
    or os.getenv("POSTGRES_URL")
    or "postgresql://traderbot:traderbot@localhost:5432/traderbot"
)


class DatabaseManager:
    """
    Manages PostgreSQL connections and operations.

    Provides a centralized interface for storing and retrieving
    configuration, state, and trading data.
    """

    def __init__(
        self,
        db_url: Optional[str] = None,
        schema: str = "public",
        min_pool_size: int = 1,
        max_pool_size: int = 5,
        connect_timeout: int = 5,
        application_name: str = "tws_traderbot",
        sslmode: str = "prefer",
    ) -> None:
        self.db_url = db_url or DEFAULT_DB_URL
        self.schema = schema or "public"
        self.min_pool_size = max(1, int(min_pool_size))
        self.max_pool_size = max(self.min_pool_size, int(max_pool_size))
        self.connect_timeout = max(1, int(connect_timeout))
        self.application_name = application_name
        self.sslmode = sslmode
        self._schema_ready = False

        conninfo = make_conninfo(
            self.db_url,
            connect_timeout=self.connect_timeout,
            application_name=self.application_name,
            sslmode=self.sslmode,
        )

        self._pool = ConnectionPool(
            conninfo=conninfo,
            min_size=self.min_pool_size,
            max_size=self.max_pool_size,
            kwargs={"autocommit": True},
        )
        self._pool.open()
        self._initialize_database()

    @contextmanager
    def get_connection(self) -> Generator[object, None, None]:
        """
        Get a database connection context manager.

        Yields:
            Active database connection
        """
        with self._pool.connection() as conn:
            self._set_search_path(conn)
            yield conn

    def close(self) -> None:
        """Close the connection pool."""
        if self._pool:
            self._pool.close()

    def _set_search_path(self, conn: object) -> None:
        if self._schema_ready and self.schema and self.schema != "public":
            conn.execute(
                sql.SQL("SET search_path TO {}")
                .format(sql.Identifier(self.schema))
            )

    def _initialize_database(self) -> None:
        """Initialize database schema if not exists."""
        with self._pool.connection() as conn:
            if self.schema and self.schema != "public":
                conn.execute(
                    sql.SQL("CREATE SCHEMA IF NOT EXISTS {}")
                    .format(sql.Identifier(self.schema))
                )
                conn.execute(
                    sql.SQL("SET search_path TO {}")
                    .format(sql.Identifier(self.schema))
                )
            self._schema_ready = True

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS config (
                    section TEXT NOT NULL,
                    key TEXT NOT NULL,
                    value JSONB NOT NULL,
                    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (section, key)
                )
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS bot_state (
                    id INTEGER PRIMARY KEY,
                    status TEXT DEFAULT 'STOPPED',
                    tws_connected BOOLEAN DEFAULT FALSE,
                    equity DOUBLE PRECISION DEFAULT 0.0,
                    daily_pnl DOUBLE PRECISION DEFAULT 0.0,
                    daily_pnl_percent DOUBLE PRECISION DEFAULT 0.0,
                    total_pnl DOUBLE PRECISION DEFAULT 0.0,
                    active_strategy TEXT DEFAULT '',
                    error_message TEXT DEFAULT '',
                    trades_today INTEGER DEFAULT 0,
                    win_rate_today DOUBLE PRECISION DEFAULT 0.0,
                    last_update TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                    last_heartbeat TIMESTAMPTZ,
                    CONSTRAINT bot_state_singleton CHECK (id = 1)
                )
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS positions (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    symbol TEXT NOT NULL,
                    quantity DOUBLE PRECISION NOT NULL,
                    entry_price DOUBLE PRECISION NOT NULL,
                    current_price DOUBLE PRECISION DEFAULT 0.0,
                    unrealized_pnl DOUBLE PRECISION DEFAULT 0.0,
                    entry_time TIMESTAMPTZ,
                    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
                )
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS orders (
                    order_id TEXT PRIMARY KEY,
                    symbol TEXT NOT NULL,
                    side TEXT NOT NULL,
                    quantity DOUBLE PRECISION NOT NULL,
                    price DOUBLE PRECISION,
                    status TEXT DEFAULT 'PENDING',
                    order_type TEXT DEFAULT 'MARKET',
                    submitted_time TIMESTAMPTZ,
                    filled_quantity DOUBLE PRECISION DEFAULT 0.0,
                    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
                )
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS logs (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                    level TEXT NOT NULL,
                    message TEXT NOT NULL
                )
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS notifications (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                    level TEXT NOT NULL,
                    message TEXT NOT NULL,
                    channel TEXT
                )
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS bot_commands (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    command TEXT NOT NULL,
                    payload JSONB,
                    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
                    processed BOOLEAN DEFAULT FALSE
                )
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS trade_history (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    symbol TEXT NOT NULL,
                    side TEXT NOT NULL,
                    quantity DOUBLE PRECISION NOT NULL,
                    price DOUBLE PRECISION NOT NULL,
                    pnl DOUBLE PRECISION DEFAULT 0.0,
                    strategy TEXT,
                    executed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
                )
                """
            )

            conn.execute(
                """
                INSERT INTO bot_state (id)
                VALUES (1)
                ON CONFLICT (id) DO NOTHING
                """
            )

            logger.info("Database initialized (schema=%s)", self.schema)

    def _decode_json(self, value: Any) -> Any:
        if isinstance(value, str):
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                return value
        return value

    # =========================================================================
    # Configuration Methods
    # =========================================================================

    def set_config(self, section: str, key: str, value: Any) -> None:
        with self.get_connection() as conn:
            conn.execute(
                """
                INSERT INTO config (section, key, value, updated_at)
                VALUES (%s, %s, %s, %s)
                ON CONFLICT (section, key)
                DO UPDATE SET value = EXCLUDED.value, updated_at = EXCLUDED.updated_at
                """,
                [section, key, Jsonb(value), datetime.utcnow()],
            )

    def get_config(self, section: str, key: str, default: Any = None) -> Any:
        with self.get_connection() as conn:
            result = conn.execute(
                "SELECT value FROM config WHERE section = %s AND key = %s",
                [section, key],
            ).fetchone()

            if result:
                return self._decode_json(result[0])
            return default

    def get_section_config(self, section: str) -> Dict[str, Any]:
        with self.get_connection() as conn:
            results = conn.execute(
                "SELECT key, value FROM config WHERE section = %s",
                [section],
            ).fetchall()

            return {row[0]: self._decode_json(row[1]) for row in results}

    def set_section_config(self, section: str, config: Dict[str, Any]) -> None:
        with self.get_connection() as conn:
            updated_at = datetime.utcnow()
            for key, value in config.items():
                conn.execute(
                    """
                    INSERT INTO config (section, key, value, updated_at)
                    VALUES (%s, %s, %s, %s)
                    ON CONFLICT (section, key)
                    DO UPDATE SET value = EXCLUDED.value, updated_at = EXCLUDED.updated_at
                    """,
                    [section, key, Jsonb(value), updated_at],
                )

    def get_all_config(self) -> Dict[str, Dict[str, Any]]:
        with self.get_connection() as conn:
            results = conn.execute(
                "SELECT section, key, value FROM config ORDER BY section, key"
            ).fetchall()

            config: Dict[str, Dict[str, Any]] = {}
            for section, key, value in results:
                if section not in config:
                    config[section] = {}
                config[section][key] = self._decode_json(value)

            return config

    def delete_config(self, section: str, key: Optional[str] = None) -> None:
        with self.get_connection() as conn:
            if key:
                conn.execute(
                    "DELETE FROM config WHERE section = %s AND key = %s",
                    [section, key],
                )
            else:
                conn.execute("DELETE FROM config WHERE section = %s", [section])

    # =========================================================================
    # Bot State Methods
    # =========================================================================

    def update_bot_state(
        self,
        status: Optional[str] = None,
        tws_connected: Optional[bool] = None,
        equity: Optional[float] = None,
        daily_pnl: Optional[float] = None,
        daily_pnl_percent: Optional[float] = None,
        total_pnl: Optional[float] = None,
        active_strategy: Optional[str] = None,
        error_message: Optional[str] = None,
        trades_today: Optional[int] = None,
        win_rate_today: Optional[float] = None,
        last_heartbeat: Optional[datetime] = None,
    ) -> None:
        updates = []
        params: List[Any] = []

        if status is not None:
            updates.append("status = %s")
            params.append(status)
        if tws_connected is not None:
            updates.append("tws_connected = %s")
            params.append(tws_connected)
        if equity is not None:
            updates.append("equity = %s")
            params.append(equity)
        if daily_pnl is not None:
            updates.append("daily_pnl = %s")
            params.append(daily_pnl)
        if daily_pnl_percent is not None:
            updates.append("daily_pnl_percent = %s")
            params.append(daily_pnl_percent)
        if total_pnl is not None:
            updates.append("total_pnl = %s")
            params.append(total_pnl)
        if active_strategy is not None:
            updates.append("active_strategy = %s")
            params.append(active_strategy)
        if error_message is not None:
            updates.append("error_message = %s")
            params.append(error_message)
        if trades_today is not None:
            updates.append("trades_today = %s")
            params.append(trades_today)
        if win_rate_today is not None:
            updates.append("win_rate_today = %s")
            params.append(win_rate_today)
        if last_heartbeat is not None:
            updates.append("last_heartbeat = %s")
            params.append(last_heartbeat)

        if updates:
            updates.append("last_update = CURRENT_TIMESTAMP")
            with self.get_connection() as conn:
                conn.execute(
                    f"UPDATE bot_state SET {', '.join(updates)} WHERE id = 1",
                    params,
                )

    def get_bot_state(self) -> Dict[str, Any]:
        with self.get_connection() as conn:
            result = conn.execute(
                """
                SELECT
                    status, tws_connected, equity, daily_pnl, daily_pnl_percent,
                    total_pnl, active_strategy, error_message, trades_today,
                    win_rate_today, last_update, last_heartbeat
                FROM bot_state WHERE id = 1
                """
            ).fetchone()

            if result:
                return {
                    "status": result[0],
                    "tws_connected": result[1],
                    "equity": result[2],
                    "daily_pnl": result[3],
                    "daily_pnl_percent": result[4],
                    "total_pnl": result[5],
                    "active_strategy": result[6],
                    "error_message": result[7],
                    "trades_today": result[8],
                    "win_rate_today": result[9],
                    "last_update": result[10].isoformat() if result[10] else None,
                    "last_heartbeat": result[11].isoformat() if result[11] else None,
                }
            return {}

    def reset_bot_state(self) -> None:
        with self.get_connection() as conn:
            conn.execute(
                """
                UPDATE bot_state SET
                    status = 'STOPPED',
                    tws_connected = FALSE,
                    equity = 0.0,
                    daily_pnl = 0.0,
                    daily_pnl_percent = 0.0,
                    total_pnl = 0.0,
                    active_strategy = '',
                    error_message = '',
                    trades_today = 0,
                    win_rate_today = 0.0,
                    last_heartbeat = NULL,
                    last_update = CURRENT_TIMESTAMP
                WHERE id = 1
                """
            )

    # =========================================================================
    # Positions Methods
    # =========================================================================

    def add_position(
        self,
        symbol: str,
        quantity: float,
        entry_price: float,
        current_price: float = 0.0,
        unrealized_pnl: float = 0.0,
        entry_time: Optional[datetime] = None,
    ) -> int:
        with self.get_connection() as conn:
            result = conn.execute(
                """
                INSERT INTO positions
                    (symbol, quantity, entry_price, current_price, unrealized_pnl, entry_time, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP)
                RETURNING id
                """,
                [symbol, quantity, entry_price, current_price, unrealized_pnl, entry_time],
            ).fetchone()
            return int(result[0])

    def update_position(
        self,
        position_id: int,
        current_price: Optional[float] = None,
        unrealized_pnl: Optional[float] = None,
        quantity: Optional[float] = None,
    ) -> None:
        updates = []
        params: List[Any] = []

        if current_price is not None:
            updates.append("current_price = %s")
            params.append(current_price)
        if unrealized_pnl is not None:
            updates.append("unrealized_pnl = %s")
            params.append(unrealized_pnl)
        if quantity is not None:
            updates.append("quantity = %s")
            params.append(quantity)

        if updates:
            updates.append("updated_at = CURRENT_TIMESTAMP")
            params.append(position_id)
            with self.get_connection() as conn:
                conn.execute(
                    f"UPDATE positions SET {', '.join(updates)} WHERE id = %s",
                    params,
                )

    def get_positions(self) -> List[Dict[str, Any]]:
        with self.get_connection() as conn:
            results = conn.execute(
                """
                SELECT id, symbol, quantity, entry_price, current_price,
                       unrealized_pnl, entry_time, updated_at
                FROM positions ORDER BY entry_time DESC NULLS LAST
                """
            ).fetchall()

            return [
                {
                    "id": row[0],
                    "symbol": row[1],
                    "quantity": row[2],
                    "entry_price": row[3],
                    "current_price": row[4],
                    "unrealized_pnl": row[5],
                    "entry_time": row[6].isoformat() if row[6] else None,
                    "updated_at": row[7].isoformat() if row[7] else None,
                }
                for row in results
            ]

    def get_position_by_symbol(self, symbol: str) -> Optional[Dict[str, Any]]:
        with self.get_connection() as conn:
            result = conn.execute(
                """
                SELECT id, symbol, quantity, entry_price, current_price,
                       unrealized_pnl, entry_time, updated_at
                FROM positions WHERE symbol = %s
                """,
                [symbol],
            ).fetchone()

            if result:
                return {
                    "id": result[0],
                    "symbol": result[1],
                    "quantity": result[2],
                    "entry_price": result[3],
                    "current_price": result[4],
                    "unrealized_pnl": result[5],
                    "entry_time": result[6].isoformat() if result[6] else None,
                    "updated_at": result[7].isoformat() if result[7] else None,
                }
            return None

    def delete_position(self, position_id: int) -> None:
        with self.get_connection() as conn:
            conn.execute("DELETE FROM positions WHERE id = %s", [position_id])

    def clear_positions(self) -> None:
        with self.get_connection() as conn:
            conn.execute("DELETE FROM positions")

    # =========================================================================
    # Orders Methods
    # =========================================================================

    def add_order(
        self,
        order_id: str,
        symbol: str,
        side: str,
        quantity: float,
        price: Optional[float] = None,
        order_type: str = "MARKET",
        status: str = "PENDING",
        submitted_time: Optional[datetime] = None,
    ) -> None:
        with self.get_connection() as conn:
            conn.execute(
                """
                INSERT INTO orders
                    (order_id, symbol, side, quantity, price, order_type, status, submitted_time, updated_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP)
                """,
                [order_id, symbol, side, quantity, price, order_type, status, submitted_time],
            )

    def update_order(
        self,
        order_id: str,
        status: Optional[str] = None,
        filled_quantity: Optional[float] = None,
        price: Optional[float] = None,
    ) -> None:
        updates = []
        params: List[Any] = []

        if status is not None:
            updates.append("status = %s")
            params.append(status)
        if filled_quantity is not None:
            updates.append("filled_quantity = %s")
            params.append(filled_quantity)
        if price is not None:
            updates.append("price = %s")
            params.append(price)

        if updates:
            updates.append("updated_at = CURRENT_TIMESTAMP")
            params.append(order_id)
            with self.get_connection() as conn:
                conn.execute(
                    f"UPDATE orders SET {', '.join(updates)} WHERE order_id = %s",
                    params,
                )

    def get_orders(self, status: Optional[str] = None) -> List[Dict[str, Any]]:
        with self.get_connection() as conn:
            if status:
                results = conn.execute(
                    """
                    SELECT order_id, symbol, side, quantity, price, status,
                           order_type, submitted_time, filled_quantity, updated_at
                    FROM orders WHERE status = %s
                    ORDER BY submitted_time DESC NULLS LAST
                    """,
                    [status],
                ).fetchall()
            else:
                results = conn.execute(
                    """
                    SELECT order_id, symbol, side, quantity, price, status,
                           order_type, submitted_time, filled_quantity, updated_at
                    FROM orders ORDER BY submitted_time DESC NULLS LAST
                    """
                ).fetchall()

            return [
                {
                    "order_id": row[0],
                    "symbol": row[1],
                    "side": row[2],
                    "quantity": row[3],
                    "price": row[4],
                    "status": row[5],
                    "order_type": row[6],
                    "submitted_time": row[7].isoformat() if row[7] else None,
                    "filled_quantity": row[8],
                    "updated_at": row[9].isoformat() if row[9] else None,
                }
                for row in results
            ]

    def get_pending_orders(self) -> List[Dict[str, Any]]:
        with self.get_connection() as conn:
            results = conn.execute(
                """
                SELECT order_id, symbol, side, quantity, price, status,
                       order_type, submitted_time, filled_quantity, updated_at
                FROM orders WHERE status IN ('PENDING', 'SUBMITTED')
                ORDER BY submitted_time DESC NULLS LAST
                """
            ).fetchall()

            return [
                {
                    "order_id": row[0],
                    "symbol": row[1],
                    "side": row[2],
                    "quantity": row[3],
                    "price": row[4],
                    "status": row[5],
                    "order_type": row[6],
                    "submitted_time": row[7].isoformat() if row[7] else None,
                    "filled_quantity": row[8],
                    "updated_at": row[9].isoformat() if row[9] else None,
                }
                for row in results
            ]

    def delete_order(self, order_id: str) -> None:
        with self.get_connection() as conn:
            conn.execute("DELETE FROM orders WHERE order_id = %s", [order_id])

    def clear_orders(self) -> None:
        with self.get_connection() as conn:
            conn.execute("DELETE FROM orders")

    # =========================================================================
    # Logs Methods
    # =========================================================================

    def add_log(self, level: str, message: str) -> None:
        with self.get_connection() as conn:
            conn.execute(
                """
                INSERT INTO logs (level, message, timestamp)
                VALUES (%s, %s, CURRENT_TIMESTAMP)
                """,
                [level, message],
            )

            conn.execute(
                """
                DELETE FROM logs WHERE id NOT IN (
                    SELECT id FROM logs ORDER BY timestamp DESC LIMIT 500
                )
                """
            )

    def get_recent_logs(self, limit: int = 50) -> List[Dict[str, Any]]:
        with self.get_connection() as conn:
            results = conn.execute(
                """
                SELECT id, timestamp, level, message
                FROM logs ORDER BY timestamp DESC LIMIT %s
                """,
                [limit],
            ).fetchall()

            return [
                {
                    "id": row[0],
                    "timestamp": row[1].isoformat() if row[1] else None,
                    "level": row[2],
                    "message": row[3],
                }
                for row in reversed(results)
            ]

    def clear_logs(self) -> None:
        with self.get_connection() as conn:
            conn.execute("DELETE FROM logs")

    # =========================================================================
    # Notifications Methods
    # =========================================================================

    def add_notification(self, level: str, message: str, channel: Optional[str] = None) -> None:
        with self.get_connection() as conn:
            conn.execute(
                """
                INSERT INTO notifications (level, message, channel, created_at)
                VALUES (%s, %s, %s, CURRENT_TIMESTAMP)
                """,
                [level, message, channel],
            )

            conn.execute(
                """
                DELETE FROM notifications WHERE id NOT IN (
                    SELECT id FROM notifications ORDER BY created_at DESC LIMIT 500
                )
                """
            )

    def get_notifications(self, limit: int = 200, offset: int = 0) -> List[Dict[str, Any]]:
        with self.get_connection() as conn:
            results = conn.execute(
                """
                SELECT id, created_at, level, message, channel
                FROM notifications ORDER BY created_at DESC LIMIT %s OFFSET %s
                """,
                [limit, offset],
            ).fetchall()

            return [
                {
                    "id": row[0],
                    "created_at": row[1].isoformat() if row[1] else None,
                    "level": row[2],
                    "message": row[3],
                    "channel": row[4],
                }
                for row in reversed(results)
            ]

    def clear_notifications(self) -> None:
        with self.get_connection() as conn:
            conn.execute("DELETE FROM notifications")

    def count_notifications(self) -> int:
        with self.get_connection() as conn:
            result = conn.execute("SELECT COUNT(*) FROM notifications").fetchone()
            return int(result[0]) if result else 0

    # =========================================================================
    # Bot Commands Methods
    # =========================================================================

    def add_command(self, command: str, payload: Optional[Dict[str, Any]] = None) -> int:
        with self.get_connection() as conn:
            result = conn.execute(
                """
                INSERT INTO bot_commands (command, payload, created_at, processed)
                VALUES (%s, %s, CURRENT_TIMESTAMP, FALSE)
                RETURNING id
                """,
                [command, Jsonb(payload) if payload else None],
            ).fetchone()
            return int(result[0])

    def get_pending_commands(self) -> List[Dict[str, Any]]:
        with self.get_connection() as conn:
            results = conn.execute(
                """
                SELECT id, command, payload, created_at
                FROM bot_commands WHERE processed = FALSE
                ORDER BY created_at ASC
                """
            ).fetchall()

            return [
                {
                    "id": row[0],
                    "command": row[1],
                    "payload": self._decode_json(row[2]) if row[2] is not None else None,
                    "created_at": row[3].isoformat() if row[3] else None,
                }
                for row in results
            ]

    def mark_command_processed(self, command_id: int) -> None:
        with self.get_connection() as conn:
            conn.execute(
                "UPDATE bot_commands SET processed = TRUE WHERE id = %s",
                [command_id],
            )

    def clear_commands(self) -> None:
        with self.get_connection() as conn:
            conn.execute("DELETE FROM bot_commands")

    # =========================================================================
    # Trade History Methods
    # =========================================================================

    def add_trade(
        self,
        symbol: str,
        side: str,
        quantity: float,
        price: float,
        pnl: float = 0.0,
        strategy: Optional[str] = None,
        executed_at: Optional[datetime] = None,
    ) -> int:
        with self.get_connection() as conn:
            result = conn.execute(
                """
                INSERT INTO trade_history (symbol, side, quantity, price, pnl, strategy, executed_at)
                VALUES (%s, %s, %s, %s, %s, %s, COALESCE(%s, CURRENT_TIMESTAMP))
                RETURNING id
                """,
                [symbol, side, quantity, price, pnl, strategy, executed_at],
            ).fetchone()
            return int(result[0])

    def get_trade_history(
        self,
        limit: int = 100,
        symbol: Optional[str] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
    ) -> List[Dict[str, Any]]:
        with self.get_connection() as conn:
            query = (
                "SELECT id, symbol, side, quantity, price, pnl, strategy, executed_at "
                "FROM trade_history WHERE 1=1"
            )
            params: List[Any] = []

            if symbol:
                query += " AND symbol = %s"
                params.append(symbol)
            if start_date:
                query += " AND executed_at >= %s"
                params.append(start_date)
            if end_date:
                query += " AND executed_at <= %s"
                params.append(end_date)

            query += " ORDER BY executed_at DESC LIMIT %s"
            params.append(limit)

            results = conn.execute(query, params).fetchall()

            return [
                {
                    "id": row[0],
                    "symbol": row[1],
                    "side": row[2],
                    "quantity": row[3],
                    "price": row[4],
                    "pnl": row[5],
                    "strategy": row[6],
                    "executed_at": row[7].isoformat() if row[7] else None,
                }
                for row in results
            ]

    def get_daily_stats(self, date: Optional[datetime] = None) -> Dict[str, Any]:
        target_date = date or datetime.now()
        date_str = target_date.strftime("%Y-%m-%d")

        with self.get_connection() as conn:
            result = conn.execute(
                """
                SELECT
                    COUNT(*) as total_trades,
                    SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as winning_trades,
                    SUM(pnl) as total_pnl,
                    AVG(pnl) as avg_pnl,
                    MAX(pnl) as max_profit,
                    MIN(pnl) as max_loss
                FROM trade_history
                WHERE DATE(executed_at) = %s
                """,
                [date_str],
            ).fetchone()

            total_trades = result[0] or 0
            winning_trades = result[1] or 0

            return {
                "date": date_str,
                "total_trades": total_trades,
                "winning_trades": winning_trades,
                "losing_trades": total_trades - winning_trades,
                "win_rate": (winning_trades / total_trades * 100) if total_trades > 0 else 0.0,
                "total_pnl": result[2] or 0.0,
                "avg_pnl": result[3] or 0.0,
                "max_profit": result[4] or 0.0,
                "max_loss": result[5] or 0.0,
            }

    def drop_schema(self) -> None:
        if not self.schema or self.schema == "public":
            return
        with self._pool.connection() as conn:
            conn.execute("SET search_path TO public")
            conn.execute(
                sql.SQL("DROP SCHEMA IF EXISTS {} CASCADE")
                .format(sql.Identifier(self.schema))
            )


_db_manager: Optional[DatabaseManager] = None


def get_database(
    db_url: Optional[str] = None,
    schema: Optional[str] = None,
    min_pool_size: Optional[int] = None,
    max_pool_size: Optional[int] = None,
    connect_timeout: Optional[int] = None,
    application_name: Optional[str] = None,
    sslmode: Optional[str] = None,
) -> DatabaseManager:
    global _db_manager

    if db_url is None:
        try:
            from src.config.settings import get_settings

            settings = get_settings()
            db_url = settings.database.url
            schema = schema or settings.database.schema
            min_pool_size = min_pool_size or settings.database.min_pool_size
            max_pool_size = max_pool_size or settings.database.max_pool_size
            connect_timeout = connect_timeout or settings.database.connect_timeout
            application_name = application_name or settings.database.application_name
            sslmode = sslmode or settings.database.sslmode
        except Exception:
            db_url = DEFAULT_DB_URL

    if _db_manager is None or (_db_manager.db_url != db_url) or (
        schema and _db_manager.schema != schema
    ):
        if _db_manager is not None:
            _db_manager.close()
        _db_manager = DatabaseManager(
            db_url=db_url,
            schema=schema or "public",
            min_pool_size=min_pool_size or 1,
            max_pool_size=max_pool_size or 5,
            connect_timeout=connect_timeout or 5,
            application_name=application_name or "tws_traderbot",
            sslmode=sslmode or "prefer",
        )
    return _db_manager


def reset_database_instance() -> None:
    global _db_manager
    if _db_manager is not None:
        _db_manager.close()
    _db_manager = None
